#  WowOpenBox by MooreaTV moorea@ymail.com (c) 2020 All rights reserved
#  Open Source Software licensed under GPLv3 - No Warranty
#  (contact the author if you need a different license)
#
#  The GNU General Public License does not permit incorporating this work
#  into proprietary programs. 
#
#  Releases detail/changes are on https://github.com/WowOpenBox/WowOpenBox/releases
#
package require Tk
package require twapi
package require TclCurl
# Try to pick up theme for OS
package require Tix
package require wm_default
wm_default::setup
wm_default::addoptions

# start not showing top level for error dialogs
wm state . withdrawn

# -- UI
set vers "1.0.0"

proc Debug {msg} {
    global settings
    if {$settings(DEBUG)} {
        puts "DEBUG $msg"
    }
}

# Settings
# -- App utils - save settings
set app_dir [file dirname [file normalize [info script]]]

set SETTINGS_FILE [file join $app_dir "wowopenboxSettings.tcl"]

proc SaveSettings {args} {
    global SETTINGS_FILE settings
    Debug "Saving settings to $SETTINGS_FILE (from cb $args)"
    set f [open $SETTINGS_FILE w+]
    puts $f "array set settings {"
    foreach i [lsort [array names settings]] {
        #  Debug "saving $i \"$settings($i)\""
        puts $f "\t$i\t\"$settings($i)\""
    }
    puts $f "}"
    close $f
}

proc LoadSettings {} {
    global SETTINGS_FILE settings
    if {[winfo exists .b1]} {
        .b1 configure -text "Edit Settings" -command EditSettings
    }
    if {[file exists $SETTINGS_FILE]} {
        if {[catch {source $SETTINGS_FILE} err]} {
            puts stderr "Could not source $SETTINGS_FILE\n$err"
            tk_messageBox -type ok -icon error -title "WoW Open Box settings error" \
                -message "Your $SETTINGS_FILE has and error: $err"
        }
    }
    RegisterHotkey "Capture" hk,capture CaptureOrUpdate
    RegisterHotkey "Start/Stop mouse tracking" hk,mouseTrack StartStopMouseTrack
    RegisterHotkey "Focus next window" hk,focusNextWindow FocusNextWindow
    RegisterHotkey "Focus previous window" hk,focusPreviousWindow FocusPreviousWindow
    RegisterHotkey "Focus follow mouse toggle" hk,focusFollowMouse FocusFollowMouseToggle
    # Set mouse control to current values
    global mouseFollow mouseRaise mouseDelay
    set mouseDelay [GetMouseDelay]
    set mouseFollow [GetFocusFollowMouse]
    set mouseRaise [GetMouseRaise]
    Debug "Settings (re)Loaded."
}

proc FocusFollowMouseToggle {} {
    Debug "Follow mouse toggle requested"
    .mf invoke
}

proc updateIndex {args} {
    global nextWindow maxNumW pos windowSize stayOnTop settings
    Debug "nextWindow is $nextWindow - args $args"
    if {[info exists settings($nextWindow,size)]} {
        set windowSize $settings($nextWindow,size)
        set pos $settings($nextWindow,posXY)
        if {[info exists settings($nextWindow,stayOnTop)]} {
            set stayOnTop $settings($nextWindow,stayOnTop)
        }
    } elseif {$nextWindow>1} {
        UpdatePos
    }
    if {$nextWindow<$maxNumW} {
        .l2 configure -text "Selected :"
        .b2 configure -text " Update "
    } else {
        .l2 configure -text "Next Wow :"
        .b2 configure -text " Capture "
    }
}

set ourTitle "WoW Open Box - Open Source Multiboxing"
proc UISetup {} {
    global vers stayOnTop pos windowSize settings mouseFollow mouseRaise mouseDelay mouseCoords ourTitle
    wm title . $ourTitle
    # Get logo
    #curl::transfer -url "https://www.wowopenbox.org/WoWOpenBox240.png?v=$vers" -bodyvar img240
    curl::transfer -url "https://www.wowopenbox.org/WoWOpenBox70.png?v=$vers" -bodyvar img70
    #set imgObj240 [image create photo -data $img240]
    set imgObj70 [image create photo -data $img70]
    wm iconphoto . -default $imgObj70
    grid [label .logo -image $imgObj70] -rowspan 3
    grid [button .bH -text "Help" -command Help]  -row 0 -column 1
    grid [button .b1  -text "Edit Settings" -command EditSettings] -row 1 -column 1
    grid [button .bwl -text "Window Layout" -command WindowLayout] -row 2 -column 1
    # label width - enough to fit "-9999 -9999"
    set width 10
    grid [label .l2 -text "Next Wow :" -anchor e] [entry .e1 -textvariable nextWindow -width $width] -padx 4 -sticky ew
    bind .e1 <FocusIn> [list focusIn %W]
    grid [label .l3 -text "Resize to" -anchor e] [entry .e2 -textvariable windowSize -width $width] -padx 4 -sticky ew
    grid [label .l4 -text "Move to" -anchor e] [entry .e3 -textvariable pos -width $width] -padx 4 -sticky ew
    grid [checkbutton .csop -text "Stay on top" -variable stayOnTop] -columnspan 2
    grid [button .b2 -text " Capture " -command CaptureOrUpdate] -pady 5 -columnspan 2
    grid [listbox .lbw -height 6] -columnspan 2 -sticky ns
    bind .lbw <<ListboxSelect>> [list selectChanged %W]
    grid [checkbutton .csfraise -text "Focus hotkey also foregrounds" -variable settings(focusAlsoFG)] -columnspan 2
    grid [label .l6 -text "Mouse settings:" -font "*-*-bold" -anchor sw] -ipady 4 -columnspan 2 -sticky sw
    grid [checkbutton .mf -text "Focus follows mouse" -variable mouseFollow -command UpdateMouseFollow] -columnspan 2 -sticky w
    grid [checkbutton .mr -text "Mouse auto foreground window" -variable mouseRaise -command UpdateMouseRaise] -columnspan 2 -sticky w
    grid [label .lmd -text "Delay (ms)"] [entry .emd -textvariable mouseDelay -width $width] -sticky w
    bind .emd <Return> UpdateMouseDelay
    grid [button .bml -text "Track mouse" -command StartStopMouseTrack] [entry .emt -textvariable mouseCoords -width $width] -sticky w
    grid [label .l_bottom -text "Wow Open Box v$vers\n\uA9 2020 MooreaTv <moorea@ymail.com>"] -columnspan 2
    grid rowconfigure    . 8 -weight 1
    #grid columnconfigure . 0 -weight 1
    grid columnconfigure . 1 -weight 1
}


proc mouseTrack {} {
    global mouseTrackOn mouseCoords
    set mouseCoords [twapi::get_mouse_location]
    set mouseTrackOn [after 100 mouseTrack]
}

proc StartStopMouseTrack {} {
    global mouseTrackOn
    if {$mouseTrackOn != ""} {
        Debug "Stopping mouse tracking"
        . configure -cursor arrow
        after cancel $mouseTrackOn
        set mouseTrackOn ""
        .bml configure -text "Track mouse"
    } else {
        Debug "Starting mouse tracking"
        . configure -cursor crosshair
        mouseTrack
        .bml configure -text "Stop tracking"
    }
}

proc focusIn {w args} {
    global nextWindow maxNumW
    Debug "got focusIn $w $args"
    if {[.lbw curselection]==""} {
        # only reset if there was a selection otherwise changing windows
        # top window clears it
        return
    }
    .lbw selection clear 0 end
    selectChanged .lbw "from focus $w"
    set nextWindow $maxNumW
}

proc selectChanged {w args} {
    global nextWindow maxNumW ww
    set sel [$w curselection]
    Debug "got selectChanged $w $args: $sel - nextWindow $nextWindow max $maxNumW"
    if {$sel != "" } {
        set nextWindow [expr {$sel+1}]
        # Not foreground, just focus
        FocusN $nextWindow false
    }
}

# --- utilities ---

proc GetHeight {} {
    global windowSize
    lindex $windowSize 1
}
proc GetWidth {} {
    global windowSize
    lindex $windowSize 0
}

proc GetX {} {
    global pos
    lindex $pos 0
}

proc GetY {} {
    global pos
    lindex $pos 1
}

# Does square first 4 windows
proc UpdatePos {} {
    global nextWindow pos
    set x [GetX]
    set y [GetY]
    Debug "x=$x y=$y"
    if {$nextWindow % 2} {
        incr y [GetHeight]
        Debug "incr y now $y"
    } else {
        set w [GetWidth]
        if {$nextWindow eq 4} {
            set w -$w
        }
        incr x $w
        Debug "incr x now $x"
    }
    set pos "$x $y"
}


# --- Windows API: https://twapi.magicsplat.com/v4.4/ui.html

proc FindWow {} {
    set w [twapi::find_windows -text "World of Warcraft" -visible true -single]
    return $w
}

proc Resize {w width height} {
    Debug "Resizing $w to $width x $height"
    twapi::resize_window $w $width $height
}

proc Rename {w name} {
    twapi::set_window_text $w $name
}

proc Move {w x y} {
    Debug "Moving $w to $x , $y"
    twapi::move_window $w $x $y
}

proc FindExisting {} {
    global nextWindow ww
    set n 1
    while {1} {
        set wname "Wow $n"
        set w [twapi::find_windows -match regexp -text "^$wname\$" -visible true -single]
        if {$w eq ""} {
            Debug "wow $n not found, stopping"
            return
        }
        Debug "found Wow $n!"
        updateListBox $n $w $wname
        incr n 1
    }
}

proc Update {wh x y w h top} {
    Resize $wh $w $h
    Move $wh $x $y
    if {$top} {
        twapi::set_window_zorder $wh toplayer
    } else {
        twapi::set_window_zorder $wh bottomlayer
    }
}

proc Focus {wh} {
    twapi::set_focus $wh
}

proc Foreground {wh} {
    twapi::set_foreground_window $wh
}

proc Help {} {
    global vers
    twapi::shell_execute -path https://www.wowopenbox.org/help?v=$vers
}

proc EditSettings {} {
    global SETTINGS_FILE
    Debug "Edit settings requested"
    twapi::shell_execute -path notepad.exe -params $SETTINGS_FILE
    .b1 configure -text "Reload Settings" -command LoadSettings
}

# Hotkeys
proc RegisterHotkey {msg var callback} {
    global settings
    Debug "RegisterHotkey $msg $var $callback"
    set hk $settings($var)
    if {[catch {twapi::register_hotkey $hk $callback} err]} {
        puts "hotkey error $hk for $msg: $err"
         tk_messageBox -type ok -icon error -title "WoW Open Box HotKey error" \
         -message "Conflict for hotkey for $msg, change $var in settings to use something different than $hk"
    }
}

proc FindOtherCopy {} {
    global ourTitle
    set w [twapi::find_windows -match regexp -text "^$ourTitle\$" -visible true -single]
    if {$w!=""} {
        catch {twapi::flash_window $w -count 3} err
        puts "Found another window of ours. Flashed it. $err"
        tk_messageBox -type ok -icon error -title "WoW Open Box duplicate error" \
          -message "Another copy of WowOpenBox is running, please exit it before starting a new one (or hotkeys will conflict)."
        catch {Foreground $w; Focus $w; twapi::flash_window $w -count 3} err
        puts "Bring other window in focus. $err"
        exit 1
    }
}
# ---

# wow windows handles
array set ww {}

proc FocusN {n fg} {
    global ww focusWindow settings
    if {![info exists ww($n)]} {
       Debug "FocusN $n called but no such window"
    }
    Debug "FocusN $n called, found window"
    Focus $ww($n)
    if {$fg && $settings(focusAlsoFG)} {
        Debug "Also making $n foreground"
        Foreground $ww($n)
    }
    set focusWindow $n
}

proc FocusNextWindow {} {
    global focusWindow maxNumW
    # maxNumW is one more than number of windows
    set n [expr {$focusWindow % ($maxNumW-1) + 1}]
    Debug "FocusNextWindow: focusWindow $focusWindow maxNumW $maxNumW -> $n"
    FocusN $n true
}

proc FocusPreviousWindow {} {
    global focusWindow maxNumW
    set n [expr {($focusWindow+$maxNumW-3) % ($maxNumW-1) + 1}]
    Debug "FocusPreviousWindow: focusWindow $focusWindow maxNumW $maxNumW -> $n"
    FocusN $n true
}

proc UpdateN {n} {
    global ww settings
    if {![info exists ww($n)]} {
        Debug "Can't update non existent window $n"
        return
    }
    if {![info exists settings($n,posXY)]} {
        Debug "Can't update window $n without settings"
        return
    }
    # local/temp only
    set lpos $settings($n,posXY)
    set lsize $settings($n,size)
    set lstayOnTop 0
    if {[info exists settings($n,stayOnTop)]} {
        set lstayOnTop $settings($n,stayOnTop)
    }
    Update $ww($n) [lindex $lpos 0] [lindex $lpos 1] [lindex $lsize 0] [lindex $lsize 1] $lstayOnTop
}

proc Swap {n1 n2} {
    global ww settings
    Debug "Swap $n1<->$n2 called"
    set tmp $ww($n2)
    set ww($n2) $ww($n1)
    set ww($n1) $tmp
    UpdateN $n1
    UpdateN $n2
}

proc Capture {} {
    global nextWindow maxNumW settings stayOnTop
    set w [FindWow]
    if {$w eq ""} {
        tk_messageBox -type ok -icon error -title "WoW Open Box Error" -message "No World of Warcraft window found"
        return
    }
    set wname "WoW $nextWindow"
    Rename $w $wname
    Update $w [GetX] [GetY] [GetWidth] [GetHeight] $stayOnTop
    updateListBox $nextWindow $w $wname
}

proc updateListBox {n w wname} {
    global ww nextWindow maxNumW settings
    set ww($n) $w
    if {[info exists settings(hk$n,focus)]} {
        Debug "Setting focus hotkey for $n / $wname: $settings(hk$n,focus)"
        RegisterHotkey "Focus window $n" hk$n,focus [list FocusN $n true]
    } else {
        Debug "No focus hotkey found or set for $n / $wname"
    }
    if {[info exists settings(hk$n,swap)]} {
        Debug "Setting swap hotkey for $n / $wname: $settings(hk$n,swap)"
        RegisterHotkey "Swap window $n" hk$n,swap [list Swap 1 $n]
    } else {
        Debug "No focus hotkey found or set for $n / $wname"
    }
    # 0 based index
    set n0 [expr {$n-1}]
    Debug "n is $n nextWindow is $nextWindow maxNumW is $maxNumW"
    if {$n<$maxNumW} {
        .lbw see $n0
        return
    }
    # jump by more than 1
    for {set i $maxNumW} {$i < $n} {incr i} {
        .lbw insert end "WoW $i*"
    }
    .lbw insert $n0 $wname
    set nextWindow [expr {$n+1}]
    set maxNumW $nextWindow
}

proc CaptureOrUpdate {} {
    global nextWindow ww settings stayOnTop
    Debug "Capturing/updating $nextWindow"
    set settings($nextWindow,posXY) "[GetX] [GetY]"
    set settings($nextWindow,size) "[GetWidth] [GetHeight]"
    set settings($nextWindow,stayOnTop) $stayOnTop
    if {![info exists ww($nextWindow)]} {
        Capture
    } else {
        UpdateN $nextWindow
    }
    SaveSettings
}


proc WindowLayout {} {
    global settings layoutOneSize monitorInfo scale
    set tw .layout
    if {[winfo exists $tw]} {
        $tw show
        return
    }
    toplevel $tw
    wm title $tw "WOB Window Layout - WORK IN PROGRESS"
    scale $tw.s -variable settings(numWindows) -orien horizontal -from 0 -to 11 -command ChangeLayout
    set layoutOneSize 1
    checkbutton $tw.cb1 -variable layoutOneSize -text "Same size for all windows" -command ChangeLayout
    grid [label $tw.l1 -text "How many windows:"] $tw.s $tw.cb1 -sticky s
    grid [canvas $tw.c -relief ridge -bd 2] -columnspan 3 -padx 5 -pady 5
    grid [button $tw.bsave -text "Save \[Work in progress... Stay tuned\]" -command SaveLayout -state disabled] -pady 10 -columnspan 3
    #tk_messageBox -type ok -icon info -title "WoW Open Box Message" -message "Not implemented yet!"
    set displayInfo [twapi::get_multiple_display_monitor_info]
    Debug "displayInfo = $displayInfo"
    set n 0
    set colors {navyblue purple orange darkgreen black}
    set smallestMonitor 0
    set biggestMonitor 0
    foreach monitor $displayInfo {
        array set info $monitor
        lassign $info(-workarea) x1 y1 x2 y2
        set monitorInfo($n,x1) $x1
        set monitorInfo($n,y1) $y1
        set monitorInfo($n,x2) $x2
        set monitorInfo($n,y2) $y2
        set width [expr {$x2-$x1}]
        set height  [expr {$y2-$y1}]
        set monitorInfo($n,width) $width
        set monitorInfo($n,height) $height
        set area [expr $width*$height]
        set monitorInfo($n,area) $area
        if {$n==0} {
            set minX $x1
            set maxX $x2
            set minY $y1
            set maxY $y2
            set minHeight $height
            set minWidth $width
            set smallestArea $area
            set biggestArea $area
        } else {
            if {$area<$smallestArea} {
                set smallestMonitor $n
                set smallestArea $area
            } elseif {$area>$biggestArea} {
                set biggestMonitor $n
                set biggestArea $area
            }
            set minX [expr min($minX,$x1)]
            set maxX [expr max($maxX,$x2)]
            set minY [expr min($minY,$y1)]
            set maxY [expr max($maxY,$y2)]
            set minHeight [expr min($minHeight, $height)]
            set minWidth [expr min($minWidth, $width)]
        }
        $tw.c create rectangle $x1 $y1 $x2 $y2 -fill [lindex $colors $n]
        incr n 1
        $tw.c create text $x2 $y2 -fill white -text "Display $n " -anchor se
        Debug "Area $x1,$y1 - $x2,$y2"
    }
    set monitorInfo(n) $n
    set monitorInfo(minHeight) $minHeight
    set monitorInfo(minWidth) $minWidth
    set monitorInfo(biggest) $biggestMonitor
    set monitorInfo(smallest) $smallestMonitor
    parray monitorInfo
    Debug "bbox 1 [$tw.c bbox all]"
    set scale [expr {1./8}]
    $tw.c scale all 0 0 $scale $scale
    Debug "bbox 2 [$tw.c bbox all]"
    set width [expr $maxX-$minX]
    set height [expr $maxY-$minY]
    $tw.c configure -width [expr {$width*$scale+8}] -height [expr {$height*$scale+8}] \
        -scrollregion [list [expr {$minX*$scale-4}] [expr {$minY*$scale-4}] [expr {$maxX*$scale}] [expr {$maxY*$scale}]]
    Debug "xview [$tw.c xview]"
    Debug "yview [$tw.c xview]"
    #$tw.c xview moveto 0
    #$tw.c yview moveto 0
#    set scrollX [expr {round($minX*-$scale)}]
#    set scrollY [expr {round($minY*-$scale)}]
#    set x [expr round(-1.5 * $minX * $scale)]
#    set y [expr round(2.5 * ($minY+$maxY) / [winfo height $tw.c])]
#    $tw.c xview scroll $x units
#    bind $tw.c <ButtonPress-1> {%W scan mark   %x %y; Debug "mark %x %y"}
#    bind $tw.c <B1-Motion>     {%W scan dragto %x %y 1; Debug "drag to %x %y"}
    Debug "$minX,$minY - $maxX,$maxY - $width x $height"
}

proc ChangeLayout {args} {
    global settings monitorInfo layoutOneSize scale
    set n $settings(numWindows)
    set c .layout.c
    $c delete wow
    Debug "ChangeLayout $args for $n - onesize $layoutOneSize"
    if {$n<=$monitorInfo(n)} {
        Debug "One Wow per monitor"
        for {set i 0} {$i<$n} {incr i} {
            set x1 $monitorInfo($i,x1)
            set y1 $monitorInfo($i,y1)
            set x2 $monitorInfo($i,x2)
            set y2 $monitorInfo($i,y2)
            if {$layoutOneSize} {
                # prioritize closer to 0,0
                if {$x1<0} {
                    set x1 [expr {$x2-$monitorInfo(minWidth)}]
                } else {
                    set x2 [expr {$x1+$monitorInfo(minWidth)}]
                }
                if {$y1<0} {
                    set y1 [expr {$y2-$monitorInfo(minHeight)}]
                } else {
                    set y2 [expr {$y1+$monitorInfo(minHeight)}]
                }
            }
            set id [expr {$i+1}]
            set tags [list "wow" "wow$id"]
            $c create rectangle $x1 $y1 $x2 $y2 -fill gold -tags $tags
            $c create text $x1 $y1 -text "\n   WoW $id" -anchor "nw" -tags $tags
            Debug "Window $id $x1,$y1 $x2,$y2"
        }
    } elseif {$monitorInfo(n)==1} {
        # Single monitor
        LayoutOneMonitor 0 1 $n $layoutOneSize
    } else {
        # cut biggest monitor in n-1 - this only works with 2 monitors...
        LayoutOneMonitorOneSize $monitorInfo(biggest) 2 [expr {$n-1}]
        LayoutOneMonitor $monitorInfo(smallest) 1 1 $layoutOneSize
    }
    $c scale wow 0 0 $scale $scale
}

proc LayoutOneMonitor {monitor startAt numWindows sameSize} {
    if {$sameSize} {
        LayoutOneMonitorOneSize $monitor $startAt $numWindows
    } else {
        LayoutOneMonitorVariable $monitor $startAt $numWindows 
    }
}

proc LayoutOneMonitorOneSize {monitor startAt numWindows} {
    global monitorInfo
    for {set i 0} {$i<=0} {incr i} {
    }
}

proc LayoutOneMonitorVariable  {monitor startAt numWindows} {

}


# --- Mouse follow focus and raise control

proc GetMouseDelay {} {
    twapi::get_system_parameters_info SPI_GETACTIVEWNDTRKTIMEOUT
}

proc SetMouseDelay {v} {
    twapi::set_system_parameters_info SPI_SETACTIVEWNDTRKTIMEOUT $v
}

proc GetFocusFollowMouse {} {
    twapi::get_system_parameters_info SPI_GETACTIVEWINDOWTRACKING
}

proc SetFocusFollowMouse {v} {
    twapi::set_system_parameters_info SPI_SETACTIVEWINDOWTRACKING $v
}

proc GetMouseRaise {} {
    twapi::get_system_parameters_info SPI_GETACTIVEWNDTRKZORDER
}

proc SetMouseRaise {v} {
    twapi::set_system_parameters_info SPI_SETACTIVEWNDTRKZORDER $v
}

# -- sync with widget values

proc UpdateMouseFollow {} {
    global mouseFollow
    SetFocusFollowMouse $mouseFollow
}

proc UpdateMouseRaise {} {
    global mouseRaise
    SetMouseRaise $mouseRaise
}

proc UpdateMouseDelay {} {
    global mouseDelay
    SetMouseDelay $mouseDelay
}

#---- settings and initial setup
# globals
if {![info exists pos]} {
    FindOtherCopy
    # position of the next move window
    set pos "0 0"
    # size to set
    set windowSize "1920 1080"
    # stay on top
    set stayOnTop 0
    # "next" window/slot #, start from slot 1
    set nextWindow 1
    # max ever set in list box
    set maxNumW 1
    # currently focused windows (at least as far as WOB is concerned)
    set focusWindow 1
}

# default hotkeys (change/add more in you wowopenboxSettings.tcl)
for {set i 1} {$i<=9} {incr i} {
    set settings(hk$i,focus) "Ctrl-F$i"
    set settings(hk$i,swap) "Ctrl-Shift-F$i"
}

array set settings {
    hk,capture "Ctrl-Shift-C"
    hk,mouseTrack "Ctrl-Shift-M"
    hk,focusNextWindow "Ctrl-Shift-N"
    hk,focusPreviousWindow "Ctrl-Shift-P"
    hk,focusFollowMouse "Ctrl-Shift-F"
    DEBUG 0
    focusAlsoFG 1
    numWindows ""
}

LoadSettings

# -- get/save sequence
trace add variable nextWindow write updateIndex

# wip for layouts
#Debug "desktop workarea [twapi::get_desktop_workarea]"
#Debug "display monitors [twapi::get_display_monitors -activeonly]"
#Debug "display info [twapi::get_multiple_display_monitor_info]"

# Make it so the code can be reloaded without errors
if {![winfo exists .logo]} {
    UISetup
    set mouseTrackOn ""
    updateIndex
    # Save settings once
    SaveSettings
}

# --- main / tweak me ---
puts "WowOpenBox $vers started..."
FindExisting
wm state . normal
